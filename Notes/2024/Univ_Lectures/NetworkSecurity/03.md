03  <!-- omit in toc -->
===

**Table of Contents**
- [0. Cont](#0-cont)
- [1. 대칭 키 암호](#1-대칭-키-암호)
  - [1. Kerckhoff의 원리](#1-kerckhoff의-원리)
  - [3. 암호분석공격](#3-암호분석공격)
- [2. 고전 암호의 분류](#2-고전-암호의-분류)
  - [1. 대치암호](#1-대치암호)
    - [1. 단일문자암호](#1-단일문자암호)
    - [2. 다중문자암호](#2-다중문자암호)
- [3. 전치 암호](#3-전치-암호)
  - [1. 키가 없는 전치 암호](#1-키가-없는-전치-암호)
  - [2. 키가 있는 전치 암호](#2-키가-있는-전치-암호)
  - [3. 두 가지 방법의 결합](#3-두-가지-방법의-결합)
      - [행렬의 사용](#행렬의-사용)

# 0. Cont
* 평문 p와 행렬 k의 행렬곱으로 암호문 c를 만들 수 있음
* 이 때 gcd(det(k), n) = 1 이어야 하고
* 따라서 det(k)가 Z_n * 중에 있어야 함(?)
> kp = c, k^-1c = p

26 = 1x21 + 5\
21 = 4x5 + 1\
1 = 21 - 4x5
= 21 - 4(26-21)
= 21x5

21 x 5 = 1 (mod 26)

# 1. 대칭 키 암호
Block 암호 vs Stream 암호
> Stream 암호의 경우 Key 수열을 생성해야 하는 문제점이 존재

## 1. Kerckhoff의 원리
키를 추측하는 것이 매우 어려워서 암호/복호 알고리즘을 비공개로 할 필요가 없는 것

## 3. 암호분석공격
1. Cipertext-only
2. Known-plaintext
3. Chosen-plaintext
4. Chosen-ciphertext
> 3, 4는 암호화 시스템에 접근 가능해야 하는 듯?

# 2. 고전 암호의 분류
## 1. 대치암호
### 1. 단일문자암호
평문의 기호와 암호문에 대응되는 기호가 1대1 대응 관계를 가짐

1. 덧셈암호
2. 이동암호(덧셈암호)
3. 시저암호(덧셈암호)
4. 곱셈암호
   * 복호화를 위해 곱셈에 사용하는 키는 역원을 가져야 함
   * 평문과 암호문이 Z_26의 원소이고, 키는 Z_26 *의 원소
5. 아핀암호
   * 덧셈암호와 곱셈암호를 결합한 암호. 곱셈을 먼저 수행
6. 단일문자 대치암호
   * 불규칙적으로 대치

### 2. 다중문자암호
1. 자동키 암호
2. 플레이페어 암호
3. Vigenere 암호
   1. Vigenere 표
4. Hill 암호
   1. 행렬곱 사용
5. 일회용 패드
6. Rotor 암호
   1. 하나 암호화 하고 Rotor 돌리고
   2. enigma 기계의 원리

# 3. 전치 암호
## 1. 키가 없는 전치 암호
1. 열 순서로 표에 기록된 뒤, 행 순서로 전송
2. 행 순서로 표에 기록된 뒤, 열 순서로 전송

## 2. 키가 있는 전치 암호
평문을 블록으로 나눈 후 키를 사용하여 암호화

```
key : 31452
enc : 31452 -> 12345
dec : 12345 -> 31452
```

## 3. 두 가지 방법의 결합
1. 평문을 표에 행 순서대로 기록
2. 열을 재배열하여 치환
3. 새 표를 열 순서로 읽음

```
0. Plain text
enemyattackstonightz

1.
enemy
attac
kston
ightz

2.
eemyn
taact
tkons
hitzg

3. Cipher text
etth eaki maot ycnz ntsg
```

#### 행렬의 사용
for key 31452
key matrix 5x5 is
```
01000
00001
10000
00100
00010
```